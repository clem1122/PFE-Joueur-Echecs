import chess

def create_compact_mapping():
    """
    Create a compact mapping of chess moves inspired by LC0's policy map.

    Returns:
        dict: A mapping from UCI strings to indices.
    """
    mapping = {}
    idx = 0

    # 1. Pawn moves (normal moves, captures, promotions)
    for file in 'abcdefgh':
        for rank in ['2', '7']:  # Starting ranks for pawns
            # Single forward move
            mapping[f"{file}{rank}{file}{int(rank)+1}"] = idx
            idx += 1
            # Double forward move
            mapping[f"{file}{rank}{file}{int(rank)+2}"] = idx
            idx += 1
        # Promotions
        for rank in ['7']:  # Promotion on 8th rank
            for promo in ['q', 'r', 'b', 'n']:
                mapping[f"{file}{rank}{file}8{promo}"] = idx
                idx += 1

    # 2. Knight moves
    knight_offsets = [
        (2, 1), (2, -1), (-2, 1), (-2, -1),
        (1, 2), (1, -2), (-1, 2), (-1, -2)
    ]
    for square in chess.SQUARES:
        file = chess.square_file(square)
        rank = chess.square_rank(square)
        for dx, dy in knight_offsets:
            target_file = file + dx
            target_rank = rank + dy
            if 0 <= target_file < 8 and 0 <= target_rank < 8:  # Inside the board
                from_square = chess.square(file, rank)
                to_square = chess.square(target_file, target_rank)
                mapping[chess.SQUARE_NAMES[from_square] + chess.SQUARE_NAMES[to_square]] = idx
                idx += 1

    # 3. King moves
    king_offsets = [
        (1, 0), (-1, 0), (0, 1), (0, -1),
        (1, 1), (1, -1), (-1, 1), (-1, -1)
    ]
    for square in chess.SQUARES:
        file = chess.square_file(square)
        rank = chess.square_rank(square)
        for dx, dy in king_offsets:
            target_file = file + dx
            target_rank = rank + dy
            if 0 <= target_file < 8 and 0 <= target_rank < 8:  # Inside the board
                from_square = chess.square(file, rank)
                to_square = chess.square(target_file, target_rank)
                mapping[chess.SQUARE_NAMES[from_square] + chess.SQUARE_NAMES[to_square]] = idx
                idx += 1

    # 4. Castling
    mapping['e1g1'] = idx  # White kingside
    idx += 1
    mapping['e1c1'] = idx  # White queenside
    idx += 1
    mapping['e8g8'] = idx  # Black kingside
    idx += 1
    mapping['e8c8'] = idx  # Black queenside
    idx += 1

    # 5. Sliding pieces (rooks, bishops, queens)
    sliding_offsets = {
        'rook': [(1, 0), (-1, 0), (0, 1), (0, -1)],
        'bishop': [(1, 1), (1, -1), (-1, 1), (-1, -1)],
        'queen': [
            (1, 0), (-1, 0), (0, 1), (0, -1),
            (1, 1), (1, -1), (-1, 1), (-1, -1)
        ],
    }
    for piece, offsets in sliding_offsets.items():
        for square in chess.SQUARES:
            file = chess.square_file(square)
            rank = chess.square_rank(square)
            for dx, dy in offsets:
                for step in range(1, 8):  # Extend the slide up to the board edge
                    target_file = file + step * dx
                    target_rank = rank + step * dy
                    if 0 <= target_file < 8 and 0 <= target_rank < 8:  # Inside the board
                        from_square = chess.square(file, rank)
                        to_square = chess.square(target_file, target_rank)
                        mapping[chess.SQUARE_NAMES[from_square] + chess.SQUARE_NAMES[to_square]] = idx
                        idx += 1
                    else:
                        break

    return mapping

# Generate the mapping
compact_mapping = create_compact_mapping()
print(f"Total moves in the mapping: {len(compact_mapping)}")

from datasets import load_dataset
dataset = load_dataset('angeluriot/chess_games')

absent_moves = set()
for i, game in enumerate(dataset['train']):
    moves_uci = game['moves_uci']
    for move in moves_uci:
        value = compact_mapping.get(move, -1)
        if value == -1:
            print(f"WARNING {move} not in mapping")
            absent_moves.add(move)

    print(f'game {i}')

print("Absent moves:", absent_moves)